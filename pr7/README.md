# Отчет по практической работе №7

## Введение
Цель работы: освоение алгоритмов сортировки массивов ("Быстрая сортировка", "Пирамидальная сортировка").

Таблица 1 - Поставленные задачи 

| Номер | Задание |
| ------------- | ------------- |
| 1| Должны быть выполнены предыдущие работы |
|2 | Прочитать про односвязные списки на СИ |
|3| Написать программу |
|4| Настроить pipeline |
|5| Написать отчет по работе в разметке Markdown (README.md)|
|6| Залить на gitlab и убедиться, что pipeline проходит успешно|
|7| Защитить работу у преподавателя|
## 1 Теоретические сведения
### 1.1 Быстрая сортировка
Быстрая сортировка — один из самых известных и широко используемых алгоритмов сортировки. Среднее время работы O(n * log n), что является асимптотически оптимальным временем работы для алгоритма, основанного на сравнении. Хотя время работы алгоритма для массива из n элементов в худшем случае может составить Θ(n^2), на практике этот алгоритм является одним из самых быстрых.

### 1.2 Пирамидальная сортировка
Пирамидальная сортировка  — алгоритм сортировки, работающий в худшем, в среднем и в лучшем случае (то есть гарантированно) за Θ(n log n) операций при сортировке n элементов. Количество применяемой служебной памяти не зависит от размера массива (то есть, O(1)).

## 2 Ход работы
### 2.1 Реализация программы на языке СИ
Общая идея алгоритма быстрой сортировки состоит в следующем:

Выбрать из массива элемент, называемый опорным. Это может быть любой из элементов массива, но лучше, когда он находится в середине массива. От выбора опорного элемента не зависит корректность алгоритма, но в отдельных случаях может сильно зависеть его эффективность и скорость.

Сравнить все остальные элементы с опорным и переставить их в массиве так, чтобы разбить массив на три непрерывных отрезка, следующих друг за другом: «элементы меньшие опорного», «равные» и «большие».

Для отрезков «меньших» и «больших» значений выполнить рекурсивно ту же последовательность операций, если длина отрезка больше единицы.

Общая идея пирамидальной сортировки заключается в том, что сначала строится пирамида из элементов исходного массива, а затем осуществляется сортировка элементов.

Выполнение алгоритма разбивается на два этапа:

1) Определяем правую часть дерева, начиная с нижнего уровня дерева. Берем элемент левее этой части массива и просеиваем его сквозь пирамиду по пути, где находятся меньшие его элементы, которые одновременно поднимаются вверх; из двух возможных путей выбираете путь через меньший элемент.

2) Берем последний элемент массива в качестве текущего. Меняем верхний (наименьший) элемент массива и текущий местами. Текущий элемент (он теперь верхний) просеиваем сквозь n-1 элементную пирамиду. Затем берем предпоследний элемент и т.д.

Программа не выдает ошибок при запуске - это означает, что она не содержит синтаксических ошибок. Так же при вводе нескольких разных значений программа выдает ожидаемый результат. Пример работы программы представлен на рисунке 1.

![](https://sun9-19.userapi.com/impg/TTn-gen0omIxnGdPvSXBTvnQrr1G9amfXe1aUQ/2Nh8lPnhpqQ.jpg?size=679x160&quality=96&sign=af0b5141ec8f8b899acc265d529093e1&type=album)

Рисунок 1 — Пример работы программы.

Из рисунка 1 видно, что программа работает корректно (выдает ожидаемый результат), а значит код написан правильно. 

#### 2.2 Работа с GitLab
Далее, внесем последние изменения в наш локальный проект и передадим его в GitLab (сделаем commit and push). Сделать этом можно прямо из среды разработки CLion.
После загрузки проекта он должен пройти pipeline проверку. 

## 3 Вывод

В результате выполнения лабораторной работы были достигнуты поставленные цели и решины необходимые задачи. Освоены алгоритмы сортировки массивов. В частности "Быстрая сортировка" и "Пирамидальная сортировка". 

По ходу выполнения лабораторной работы были закреплены теоретические сведения, полученные на лекционных занятиях.

## Приложение A

(обязательное)

Листининг кода  первой программы

```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <malloc.h>
#include <time.h>
FILE* f;
int heapUp(int Arr[], int Size, int* t)
{
	int i, iS, j, r, l, RD, LD, v, N = Size;
	iS = (Size / 2) - 1;
	while (Size != 0)
	{
		i = iS;
		while (i != (-1))
		{
			j = i;
			while (1)
			{
				l = 2 * j + 1;
				r = 2 * j + 2;
				if (l < Size)
					LD = Arr[l];
				else
					LD = -1001;
				if (r < Size)
					RD = Arr[r];
				else
					RD = -1001;
				if (RD > LD)
				{
					if (RD > Arr[j])
					{
						v = Arr[j];
						Arr[j] = Arr[r];
						Arr[r] = v;
						j = r;
						//
						if ((*t) != 0)
							fprintf(f, "\n");
						else
							(*t)++;
						for (int k = 0; k < N; k++)
						{
							if (k != 0)
								fprintf(f, " ");
							fprintf(f, "%d", Arr[k]);
						}
						//
					}
					else
						break;
				}
				else
				{
					if (LD > Arr[j])
					{
						v = Arr[j];
						Arr[j] = Arr[l];
						Arr[l] = v;
						j = l;
						//
						if ((*t) != 0)
							fprintf(f, "\n");
						else
							(*t)++;
						for (int k = 0; k < N; k++)
						{
							if (k != 0)
								fprintf(f, " ");
							fprintf(f, "%d", Arr[k]);
						}
						//
					}
					else
						break;
				}
			}
			i--;
		}
		Size--;
		if (Arr[0] > Arr[Size])
		{
			v = Arr[0];
			Arr[0] = Arr[Size];
			Arr[Size] = v;
			//
			if ((*t) != 0)
				fprintf(f, "\n");
			else
				(*t)++;
			for (int k = 0; k < N; k++)
			{
				if (k != 0)
					fprintf(f, " ");
				fprintf(f, "%d", Arr[k]);
			}
			//
		}
	}
	return 0;
}
int quickUp(int Arr[], int B, int E, int N, int* t)
{
	int i = B, j = E, v = 0, el = Arr[(E + B) / 2], elN = (E + B) / 2;
	while (1)
	{
		while (Arr[i] < el)
			i++;
		while (Arr[j] > el)
			j--;
		if (i < j)
		{
			v = Arr[i];
			Arr[i] = Arr[j];
			Arr[j] = v;
			//
			if (i != elN)
				j--;
			else
				elN = j;
			if ((j + 1) != elN)
				i++;
			else
				elN = i;
			if ((*t) != 0)
				fprintf(f, "\n");
			else
				(*t)++;
			for (int k = 0; k < N; k++)
			{
				if (k != 0)
					fprintf(f, " ");
				fprintf(f, "%d", Arr[k]);
			}
			//
		}
		else
			break;
	}
	if ((i - B - 1) > 0)
		quickUp(Arr, B, i - 1, N, t);
	if ((E - i - 1) > 0)
		quickUp(Arr, i + 1, E, N, t);
	return 0;
}
int main()
{
	int* Arr = (int*)malloc(sizeof(int)), * CArr = (int*)malloc(sizeof(int)), N, i, t = 0;
	double k;
	scanf("%lf", &k);
	N = k;
	Arr = (int*)realloc(Arr, N * sizeof(int));
	CArr = (int*)realloc(CArr, N * sizeof(int));
	for (i = 0; i < N; i++)
	{
		scanf("%lf", &k);
		Arr[i] = k;
		CArr[i] = k;
	}
	f = fopen("quicksort.log", "w+");
	fclose(f);
	f = fopen("quicksort.log", "w+");
	quickUp(Arr, 0, N - 1, N, &t);
	fclose(f);
	t = 0;
	f = fopen("heapsort.log", "w+");
	fclose(f);
	f = fopen("heapsort.log", "r+");
	heapUp(CArr, N, &t);
	fclose(f);
	for (int k = 0; k < N; k++)
	{
		if (k != 0)
			printf(" ");
		printf("%d", Arr[k]);
	}
	return 0;
}
```
